/*
 * Main Doom Object - Called from the Thump.main()
 */
package thump.game;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import thump.game.Event.GameAction;
import static thump.game.Event.GameAction.ga_nothing;
import static thump.game.Event.MAXEVENTS;
import static thump.game.Player.PlayerState.PST_LIVE;
import static thump.global.Defines.DEVDATA;
import static thump.global.Defines.DEVMAPS;
import thump.global.Defines.GameMode;
import static thump.global.Defines.GameMode.COMMERCIAL;
import thump.global.Defines.GameState;
import static thump.global.Defines.GameState.GS_DEMOSCREEN;
import static thump.global.Defines.GameState.GS_LEVEL;
import static thump.global.Defines.SAVEGAMENAME;
import static thump.global.Defines.SCREENHEIGHT;
import static thump.global.Defines.SCREENWIDTH;
import thump.global.Defines.Skill;
import static thump.global.Defines.VERSION;
import static thump.global.Defines.logger;
import thump.global.SystemInterface;
import thump.global.VideoInterface;
import thump.menu.MenuManager;
import static thump.network.Net.BACKUPTICS;
import thump.render.Wipe;
import static thump.sound.sfx.Sounds.MusicEnum.*;
import thump.system.ThumpLogger;
import thump.wad.WadLoader;
import thump.wad.lump.PictureLump;

/**
 *
 * @author mark
 */
public final class DoomMain {

    // Move to messageBundle
    private String title = "Thump -- A DOOM port in Java";
        
    private Game  game = Game.getInstance();
    private MenuManager menu = MenuManager.getInstance();
    
    private String homeDir = System.getProperty("user.home" );
    private String doomWadDir = homeDir + File.separator + "Documents"  + File.separator + "Doom";
    public boolean advancedemo = false;
    public String basedefault = "";
    
    private final ArrayList<String> wadList = new ArrayList<>();
    //private final String SAVEGAMENAME = "doomsave";

    // debug flag to cancel adaptiveness
    public  boolean singletics = true;	// Debug.  No net
    public  boolean devparm;            // DEBUG: launched with -devparm
    
    public  Skill       startskill = Skill.sk_medium;
    public  int         startepisode = 1;
    public  int		startmap = 1;
    public  boolean     autostart;

    //
    //  DEMO LOOP
    //
    int             demosequence;
    int             pagetic;
    String          pagename;
    private int fps;
    
    //
    // EVENT HANDLING
    //
    // Events are asynchronous inputs generally generated by the game user.
    // Events can be discarded if no responder claims them
    //
    Event   events[] = new Event[MAXEVENTS];
    int     eventhead;
    int     eventtail;

        
    public DoomMain( List<String> args) throws FileNotFoundException {
        game.args = args;
        ThumpLogger.init();  // Sets up or logging handlers and level.
        game.setDoomMain(this);
        
        logger.log(Level.CONFIG, "Init Graphics: Creating Window.\n");
        game.videoInterface.I_InitGraphics();
        
        logger.log(Level.CONFIG, "{0}\n", title);
        
        int p;
        
        String file;

        findResponseFile();

        identifyVersion();
                
        //modifiedgame = false;
        game.nomonsters = game.isParam("-nomonsters");
        game.respawnparm = game.isParam("-respawn");
        game.fastparm = game.isParam("-fast");
        devparm = game.isParam("-devparm");
        if (args.indexOf("-altdeath") > -1) {
            game.deathmatch = 2;
        } else if (args.indexOf("-deathmatch") > -1) {
            game.deathmatch = 1;
        }

        // TODO  check for -lang param  (French or English for now.)
        
        switch (game.gameMode) {
            case RETAIL:
                title = "The Ultimate DOOM Startup v" + VERSION / 100 + "." + VERSION % 100;
                break;
            case SHAREWARE:
                title = "DOOM Shareware Startup v" + VERSION / 100 + "." + VERSION % 100;
                break;
            case REGISTERED:
                title = "DOOM Registered Startup v" + VERSION / 100 + "." + VERSION % 100;
                break;
            case COMMERCIAL:
                title = "DOOM 2: Hell on Earth v" + VERSION / 100 + "." + VERSION % 100;
                break;
//            FIXME
//       case pack_plut:
//	sprintf (title,
//		 "                   "
//		 "DOOM 2: Plutonia Experiment v%i.%i"
//		 "                           ",
//		 VERSION/100,VERSION%100);
//	break;
//      case pack_tnt:
//	sprintf (title,
//		 "                     "
//		 "DOOM 2: TNT - Evilution v%i.%i"
//		 "                           ",
//		 VERSION/100,VERSION%100);
//	break;
             
            default:
                title = "Public DOOM - v" + VERSION / 100 + "." + VERSION % 100;
            break;
        }

        logger.log(Level.CONFIG, "{0}\n", title);

        if (devparm) {
            logger.log(Level.CONFIG, "{0}\n", Game.messages.getString("D_DEVSTR"));
        }

        if (game.isParam("-cdrom")) {
            logger.log(Level.CONFIG, Game.messages.getString("D_CDROM"));
//            mkdir("c:\\doomdata", 0);
//            strcpy(basedefault, "c:/doomdata/default.cfg");
        }

        // turbo option
        p = args.indexOf("-turbo");
        if (p > -1) {
            int scale = 200;

            if (p < args.size() - 2) {
                scale = Integer.valueOf(args.get(p + 1));
            }
            
            if (scale < 10) {
                scale = 10;
            }
            if (scale > 400) {
                scale = 400;
            }
            logger.log(Level.CONFIG, "turbo scale: {0}\n", scale);
            
            game.forwardmove[0] = game.forwardmove[0] * scale / 100;
            game.forwardmove[1] = game.forwardmove[1] * scale / 100;
            game.sidemove[0] = game.sidemove[0] * scale / 100;
            game.sidemove[1] = game.sidemove[1] * scale / 100;
        }

        // convenience hack to allow -wart e m to add a wad file
        // prepend a tilde to the filename so wadfile will be reloadable
        p = args.indexOf("-wart");
        if (p > -1) {
            //args[p][4] = 'p';     // big hack, change to -warp
            args.set(p, "-warp");

            // Map name handling.
            switch (game.gameMode) {
                case SHAREWARE:
                case RETAIL:
                case REGISTERED:
                    file = "~" + DEVMAPS + "E" + args.get(p+1).charAt(0) + "M" + args.get(p+2).charAt(0) + ".wad";
                    logger.log(Level.CONFIG, "Warping to Episode {0}, Map {1}.\n", new Object[]{args.get(p+1), args.get(p+2)});
                    break;

                case COMMERCIAL:
                default:
                    //p = atoi(args[p + 1]);
                    p = Integer.valueOf(args.get(p+1));
                    if (p < 10) {
                        file = "~" + DEVMAPS + "cdata" + File.separator + "map0" + p + ".wad";
                        
//                        slogger.log(Level.CONFIG, file, "~" DEVMAPS"cdata/map0%i.wad", p);
                    } else {
                        file = "~" + DEVMAPS + "cdata" + File.separator + "map" + p + ".wad";
//                      slogger.log(Level.CONFIG, file, "~"DEVMAPS"cdata/map%i.wad", p);
                    }
                    break;
            }
            wadList.add(file);
        }

        // add any files specified on the command line with -file wadfile
        // to the wad list
        //
        p = args.indexOf("-file");
        if (p>-1) {
            // the parms after p are wadfile/lump names,
            // until end of parms or another - preceded parm
            game.modifiedgame = true;            // homebrew levels
            while (++p != args.size() && args.get(p).charAt(0) != '-') {
                wadList.add(args.get(p));
                logger.log(Level.CONFIG, "Adding file: {0}\n", args.get(p));
            }
        }

        p = args.indexOf("-playdemo");
        if (p == -1) {
            p = args.indexOf("-timedemo");
        }

        if (p>-1 && p < args.size() - 2) {
            //slogger.log(Level.CONFIG, file, "%s.lmp", args.get(p+1));
            wadList.add(args.get(p + 1) + ".lmp");
            //D_AddFile(file);
            //logger.log(Level.CONFIG, "Playing demo %s.lmp.\n", args.get(p+1));
            logger.log(Level.CONFIG, "Playing demo {0}.lmp.\n", args.get(p + 1));
        }

        // get skill / episode / map from parms
        p = args.indexOf("-skill");
        if (p>-1 && p < args.size() - 2) {
            startskill = Skill.skill(Integer.valueOf(args.get(p + 1)));
            autostart = true;
        }

        p = args.indexOf("-episode");
        if (p>-1 && p < args.size() - 2) {
            startepisode = Integer.valueOf(args.get(p+1).charAt(0));
            startmap = 1;
            autostart = true;
        }

        p = args.indexOf("-timer");
        if (p>-1 && p < args.size() - 2 && game.deathmatch > 0) {
            int time;
            time = Integer.valueOf(args.get(p + 1));
            logger.log(Level.CONFIG, "Levels will end after {0} minute", time);
            if (time > 1) {
                logger.log(Level.CONFIG, "s");
            }
            logger.log(Level.CONFIG, ".\n");
        }

        p = args.indexOf("-avg");
        if (p>-1 && p < args.size() - 2 && game.deathmatch > 0) {
            logger.log(Level.CONFIG, "Austin Virtual Gaming: Levels will end after 20 minutes.\n");
        }

        p = args.indexOf("-warp");
        if (p>-1 && p < args.size() - 2) {
            if (game.gameMode == GameMode.COMMERCIAL) {
                startmap = Integer.valueOf(args.get(p + 1).charAt(0));
            } else {
                startepisode = Integer.valueOf(args.get(p+1).charAt(0));
                startmap = Integer.valueOf(args.get(p+2).charAt(0));
            }
            autostart = true;
        }

        // init subsystems
        game.video.init();


        logger.log(Level.CONFIG, "Load misc. defaults.\n");
        menu.initDefaultProperties();// load before initing other systems
        // TODO  Video initDefaultProperties
        // TODO  Sound initDefaultProperties


// Zone is malloc stuff.  We don't need it for Java.
//        logger.log(Level.CONFIG, "Z_Init: Init zone memory allocation daemon. ");
//        Z_Init();


// Not yet ready for external WAD add-ons.
//TODO        W_InitMultipleFiles(wadfiles);
        

        game.wad = WadLoader.getWad(new File(wadList.get(0)));

        
/*        
        // Not ready for any of this
        
        // Check for -file in shareware
        if (modifiedgame) {
            // These are the lumps that will be checked in IWAD,
            // if any one is not present, execution will be aborted.
            String[] name = 
            //char name[23][8]=
	{
	    "e2m1","e2m2","e2m3","e2m4","e2m5","e2m6","e2m7","e2m8","e2m9",
	    "e3m1","e3m3","e3m3","e3m4","e3m5","e3m6","e3m7","e3m8","e3m9",
	    "dphoof","bfgga0","heada1","cybra1","spida1d1"
	};
            int i;

            if (gameMode == GameMode.SHAREWARE) {
//TODO                I_Error("\nYou cannot -file with the shareware " +
//            "version. Register!"
//            );

	// Check for fake IWAD with right name,
	// but w/o all the lumps of the registered version. 
	if (gameMode == GameMode.REGISTERED) {
                for (i = 0; i < 23; i++) {
                    if (W_CheckNumForName(name[i]) < 0) {
//TODO                        I_Error("\nThis is not the registered version.");
                    }
                }
            }
        }

        // If additonal PWAD files are used, print modified banner
        if (modifiedgame) {
            logger.log(Level.CONFIG, 
            "===========================================================================\n" +
            "ATTENTION:  This version of DOOM has been modified.  If you would like to\n" +
	    "get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n" +
	    "        You will not receive technical support for modified games.\n" +
	    "                      press enter to continue\n" +
	    "===========================================================================\n" 
	    );
            getchar();
        }
*/
        // Check and print which version is executed.
        switch (game.gameMode) {
            case SHAREWARE:
            case INDETERMINED:
                logger.log(Level.CONFIG, 
                "\n" +
                "==============================LEGACY MESSAGE===============================\n" +
                "                                Shareware!\n" +
                "===========================================================================\n"
                );
                break;
            case REGISTERED:
            case RETAIL:
            case COMMERCIAL:
                logger.log(Level.CONFIG,
                    "\n" +
                    "===============================LEGACY MESSAGE==============================\n" +
                    "                 Commercial product - do not distribute!\n" +
                    "         Please report software piracy to the SPA: 1-800-388-PIR8\n" +
                    "===========================================================================\n"
                );
                break;

            default:
                // Ouch.
                break;
        }

        logger.log(Level.CONFIG, "M_Init: Init Menus.\n");
        menu.M_Init();

        logger.log(Level.CONFIG, "R_Init: Init DOOM render daemon.\n");
        game.renderer.R_Init();

        logger.log(Level.CONFIG, "P_Init: Init Playloop state.\n");
        game.playerSetup.P_Init();

        logger.log(Level.CONFIG, "I_Init: Setting up machine state.\n");
        SystemInterface.getInstance().I_Init();

        logger.log(Level.CONFIG, "D_CheckNetGame: Checking network game status.\n");
        game.net.D_CheckNetGame();

        logger.log(Level.CONFIG, "S_Init: Setting up sound.\n");
        game.sound.S_Init(100 , 100 );  // Menu will re-load with the defaults.

        logger.log(Level.CONFIG, "HU_Init: Setting up heads up display.\n");
        game.headUp.HU_Init();

        logger.log(Level.CONFIG, "ST_Init: Init status bar.\n");
        game.statusBar.ST_Init();

// TODO
//        // check for a driver that wants intermission stats
//        p = args.indexOf("-statcopy");
//        if (p>0 && p < args.size() - 1) {
//            // for statistics driver
//            //extern  void * statcopy;
//
//            //statcopy = (void *)atoi(args.get(p+1));
//            statcopy = Integer.valueOf(args[p+1]);
//            logger.log(Level.CONFIG, "External statistics registered.");
//        }
//


        // start the apropriate game based on parms
        p = args.indexOf("-record");

        if (p>0 && p < args.size() - 1) {
//TODO            G_RecordDemo(args.get[p + 1]);
            autostart = true;
        }

        p = args.indexOf("-playdemo");
        if (p>0 && p < args.size() - 1) {
            game.singledemo = true;              // quit after one demo
            game.G_DeferedPlayDemo(args.get(p+1));
            doomLoop();  // never returns
        }

        p = args.indexOf("-timedemo");
        if (p>0 && p < args.size() - 1) {
//TODO            G_TimeDemo(args.get(p+1));
            doomLoop();  // never returns
        }

        p = args.indexOf("-loadgame");
        if (p>0 && p < args.size() - 1) {
            if (args.indexOf("-cdrom") > 0) {
                file = "c:\\doomdata\\"+SAVEGAMENAME + args.get(p + 1).charAt(0) + ".dsg";
                //sprintf( file, "c:\\doomdata\\"SAVEGAMENAME"%c.dsg",args.get(p+1)[0]);
            } else {
                file = SAVEGAMENAME + args.get(p + 1).charAt(0) + ".dsg";
                //sprintf( file, SAVEGAMENAME"%c.dsg",args.get(p+1)[0]);
//TODO            G_LoadGame(file);
            }
        }

        if (game.gameaction != GameAction.ga_loadgame) {
            if (autostart || game.netgame) {
                logger.log(Level.CONFIG, "Call G_InitNew.\n");
                game.G_InitNew(startskill, startepisode, startmap);
            } else {
                logger.log(Level.CONFIG, "Call D_StartTitle.\n");
                D_StartTitle();                // start up intro loop
            }
        }

        if (game.demorecording) {
//TODO            G_BeginRecording();
        }

        if ( game.isParam("-debugfile") ) {
        
            //char filename[20];
            //sprintf(filename, "debug%i.txt", consoleplayer);
            String filename = "debug" + game.consoleplayer + ".txt";
            logger.log(Level.CONFIG, "debug output to: {0}\n", filename);
//TODO            debugfile = fopen(filename, "w");
        }

        menu.setCurrentMenu(menu.mainMenu);
        doomLoop();  // never returns

    }
    
    //
    // D_PostEvent
    // Called by the I/O functions when input is detected
    //
    public void D_PostEvent (Event ev) {
        events[eventhead] = ev;
        eventhead++;
        eventhead &= (MAXEVENTS-1);
    }

    //
    // D_ProcessEvents
    // Send all the events of the given timestamp down the responder chain
    //
    public void D_ProcessEvents () {
        Event	ev;

        //Defines.logger.config("D_ProcessEvents\n");

        // IF STORE DEMO, DO NOT ACCEPT INPUT
        if ( ( game.gameMode == COMMERCIAL )
             && (game.wad.findByName("map01")==null )
             && (game.wad.findByName("MAP01")==null )  ) {
            return;
        }

        for ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS-1) ) {
            ev = events[eventtail];

            if (menu.M_Responder (ev)) {
                continue;               // menu ate the event
            }
            game.G_Responder (ev);
        }
    }
                
    //
    // D_Display
    //  draw current display, possibly wiping it from the previous
    //

    // wipegamestate can be set to -1 to force a wipe on the next draw
    public GameState wipegamestate     = GS_DEMOSCREEN;

    public boolean viewactivestate     = false;
    public boolean menuactivestate     = false;
    public boolean inhelpscreensstate  = false;
    public boolean fullscreen          = false;
    public int     borderdrawcount;
    private    GameState oldgamestate = GameState.GS_NONE;
        
    void D_Display () {
        long			nowtime;
        long			tics;
        long			wipestart;
        int			y;
        boolean			done;
        boolean			wipe;
        boolean			redrawsbar;

        //logger.config("D_Display()\n");
        
        if (game.nodrawers) {
            return;                    // for comparative timing / profiling
        }
        //game.video.screens[0].clear();

        redrawsbar = false;

        // change the view size if needed
        if (game.renderer.setsizeneeded) {  // setsizein r_main
            game.renderer.R_ExecuteSetViewSize ();
            oldgamestate = GameState.GS_NONE;                      // force background redraw
            borderdrawcount = 3;
        }

        // save the current screen if about to wipe
        if (game.gamestate != wipegamestate) {
            logger.config("Set Wipe Gamestate\n");
            wipe = true;
            Wipe.getInstance().wipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);
        } else {
            wipe = false;
        }

        if (game.gamestate == GS_LEVEL && game.gametic>0) {
            //logger.config("HeadUp Erase\n");
            game.headUp.HU_Erase();
        }

        // do buffered drawing
        switch (game.gamestate) {
          case GS_LEVEL:
            //logger.config("GS_LEVEL\n");
            if (game.gametic==0) {
                break;
            }
            if (game.autoMap.automapactive) {
                game.autoMap.AM_Drawer ();
            }
            if (wipe || (game.renderer.draw.viewheight != 200 && fullscreen) ) {
                redrawsbar = true;
            }
            if (inhelpscreensstate && !menu.inhelpscreens) {
                redrawsbar = true;              // just put away the help screen
            }
            game.statusBar.ST_Drawer (game.renderer.draw.viewheight == 200, redrawsbar );
            fullscreen = game.renderer.draw.viewheight == 200;
            break;

          case GS_INTERMISSION:
            logger.config("GS_INTERMISSION\n");
            game.intermission.WI_Drawer ();
            break;

          case GS_FINALE:
            logger.config("GS_FINALE\n");
            game.finale.F_Drawer ();
            break;

          case GS_DEMOSCREEN:
            //logger.config("GS_DEMOSCREEN\n");
            D_PageDrawer ();
            break;
        }

        // draw buffered stuff to screen
        //logger.config("Render Update - No Blit\n");
        game.videoInterface.I_UpdateNoBlit();
        //VideoInterface.getInstance().I_FinishUpdate();

        // draw the view directly
        if (game.gamestate == GS_LEVEL && !game.autoMap.automapactive && game.gametic>0) {
            logger.finer("Render Player View\n");
            game.renderer.R_RenderPlayerView (game.players[game.displayplayer]);
            
            if (game.gamestate == GS_LEVEL && game.gametic>0) {
                game.headUp.HU_Drawer ();
            }
        }

        // clean up border stuff
        if (game.gamestate != oldgamestate && game.gamestate != GS_LEVEL) {
            //logger.config("Set Palette\n");
            game.videoInterface.I_SetPalette (game.wad.getPlayPalLump().paletteList.get(0));
        }

        // see if the border needs to be initially drawn
        if (game.gamestate == GS_LEVEL && oldgamestate != GS_LEVEL) {
            logger.config("Fill Back Screen\n");
            viewactivestate = false;        // view was not active
            game.renderer.draw.R_FillBackScreen ();    // draw the pattern into the back screen
        }

        // see if the border needs to be updated to the screen
        if (game.gamestate == GS_LEVEL && !game.autoMap.automapactive && game.renderer.draw.scaledviewwidth != 320) {
            //logger.config("Update Border\n");
            if (menu.menuactive || menuactivestate || !viewactivestate) {
                borderdrawcount = 3;
            }
            
            if (borderdrawcount>0) {
                game.renderer.draw.R_DrawViewBorder ();    // erase old menu stuff
                borderdrawcount--;
            }

        }

        menuactivestate = menu.menuactive;
        viewactivestate = game.viewactive;
        inhelpscreensstate = menu.inhelpscreens;
        oldgamestate = game.gamestate;
        wipegamestate = game.gamestate;

        // draw pause pic
        if (game.paused) {
            logger.config("Draw Pause Pic\n");
            if (game.autoMap.automapactive) {
                y = 4;
            } else {
                y = game.renderer.draw.viewwindowy+4;
            }
            game.video.drawPatchDirect(
                    game.renderer.draw.viewwindowx+(game.renderer.draw.scaledviewwidth-68)/2,
                    y,0,"M_PAUSE");
        }


        // menus go directly to the screen
        menu.M_Drawer ();          // menu is drawn even on top of everything
        game.net.NetUpdate ();         // send out any new accumulation

        // normal update
        if (!wipe) {
            game.videoInterface.I_FinishUpdate ();              // page flip or blit buffer
            return;
        }


        // wipe update
        Wipe.getInstance().wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);

        wipestart = SystemInterface.getInstance().I_GetTime() - 1;

        do {
            do {
                nowtime = SystemInterface.getInstance().I_GetTime();
                tics = nowtime - wipestart;
            } while (tics<=0);
            wipestart = nowtime;
            done = Wipe.getInstance().wipe_ScreenWipe(Wipe.Wipes.wipe_Melt, 0, 0, SCREENWIDTH, SCREENHEIGHT, (int) tics);
            game.videoInterface.I_UpdateNoBlit();
            menu.M_Drawer();   // menu is drawn even on top of wipes
            game.videoInterface.I_FinishUpdate();   // page flip or blit buffer
        } while (!done);
        
        // Wipe blows away any redraw for the status bar.
        // Works fine in legacy C edition but not here in our port.
        // So we set the flag after the redraw is done.
        game.statusBar.ST_Drawer (game.renderer.draw.viewheight == 200, redrawsbar );

    }



    private void doomLoop() {
        long lastTime = System.currentTimeMillis();
        while (true) {
            fps = (int) (1000/(System.currentTimeMillis()-lastTime+1));
            //logger.log(Level.CONFIG, "Tics elapsed: {0}\n", System.currentTimeMillis()-lastTime);
            lastTime = System.currentTimeMillis();
            // frame syncronous IO operations
//            I_StartFrame();  // Does nothing for us.

            // process one or more lastTime
            if (singletics) {
                VideoInterface.getInstance().I_StartTic();
                //Defines.logger.config("doomLoop D_ProcessEvents\n");

                D_ProcessEvents();
                game.G_BuildTiccmd( game.net.netcmds[game.consoleplayer], game.net.maketic % BACKUPTICS);
                if (advancedemo) {
                    logger.config("D_DoAdvanceDemo\n");
                    D_DoAdvanceDemo();
                }
                //logger.config("M_Ticker\n");
                menu.M_Ticker();
                //logger.config("game.G_Ticker\n");
                game.G_Ticker();
                game.gametic++;
                game.net.maketic++;
            } else {
                logger.config("DryRunTics\n");
                game.net.TryRunTics(); // will run at least one tic
            }

            game.sound.S_UpdateSounds(game.players[game.consoleplayer].mo);// move positional sounds

            // Update display, next frame, with current state.
            D_Display();
//            #
//            ifndef SNDSERV // Sound mixing for the buffer is snychronous.
            game.sound.UpdateSound();
//            #endif // Synchronous sound output is explicitly called.
//
//            #ifndef SNDINTR // Update sound output.
            game.sound.soundInterface.I_SubmitSound();
//            #endif
            
            
            // Sleep in a way to keep the doom loop at 30 fps
            try { Thread.sleep(27); } catch (Exception e) {}

        }
    }

//
// Find a Response File
//
    private void findResponseFile() throws FileNotFoundException {
        int MAXARGVS = 100;

        for (int i = 1; i < game.args.size(); i++) {
            
            if ( game.args.get(i).startsWith("@") ) {
            //if (args[i].charAt(0) == '@') {
                //FILE * handle;
                int size;
                int k;
                int index;
                int indexinfile;
                String infile;
                String file;
                //String moreargs[20];
                String firstargv;

                // READ THE RESPONSE FILE INTO MEMORY
                //handle = fopen( & myargv[i][1], "rb");
                String fileName = game.args.get(i).substring(i);
                File handle = new File(fileName);
                //if (!handle) {
                if (!handle.exists()) {
                    logger.log(Level.CONFIG, "No such response file! File {0}", fileName );
                    //logger.log(Level.CONFIG, "\nNo such response file!");
                    //exit(1);
                    throw new FileNotFoundException("No such response file! File: " + fileName );

                }
                //logger.log(Level.CONFIG, "Found response file %s!\n",  & myargv[i][1]);
                logger.log(Level.CONFIG, "Found response file {0}", fileName);
// TODO response file.
//            fseek(handle, 0, SEEK_END);
//            size = ftell(handle);
//            fseek(handle, 0, SEEK_SET);
//            file = malloc(size);
//            fread(file, size, 1, handle);
//            fclose(handle);

//            // KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG
//            for (index = 0, k = i + 1; k < myargc; k++) {
//                moreargs[index++] = myargv[k];
//            }
//
//            firstargv = myargv[0];
//            myargv = malloc(sizeof(char *) * MAXARGVS);
//            memset(myargv, 0, sizeof(char *) * MAXARGVS);
//            myargv[0] = firstargv;
//
//            infile = file;
//            indexinfile = k = 0;
//            indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)
//            do {
//                myargv[indexinfile++] = infile + k;
//                while (k < size
//                        && (( * (infile + k) >= ' ' + 1) && ( * (infile + k) <= 'z'))) {
//                    k++;
//                }
//                 * (infile + k) = 0;
//                while (k < size
//                        && (( * (infile + k) <= ' ') || ( * (infile + k) > 'z'))) {
//                    k++;
//                }
//            } while (k < size);
//
//            for (k = 0; k < index; k++) {
//                myargv[indexinfile++] = moreargs[k];
//            }
//            myargc = indexinfile;
//
//            // DISPLAY ARGS
//            logger.log(Level.CONFIG, "%d command-line args:\n", myargc);
//            for (k = 1; k < myargc; k++) {
//                logger.log(Level.CONFIG, "%s\n", myargv[k]);
//            }
//
//            break;
            }
        }
    }
    
    //
    // D_PageTicker
    // Handles timing for warped projection
    //
    void D_PageTicker () {
        if (--pagetic < 0)
            D_AdvanceDemo ();
    }



    //
    // D_PageDrawer
    //
    void D_PageDrawer () {
        game.video.drawPatch(0,0, 0, ((PictureLump)game.wad.findByName(pagename)).pic);
    }


    //
    // D_AdvanceDemo
    // Called after each demo or intro demosequence finishes
    //
    public void D_AdvanceDemo () {
        advancedemo = true;
    }


    //
    // This cycles through the demo sequences.
    // FIXME - version dependend demo numbers?
    //
    public void D_DoAdvanceDemo () {
        game.players[game.consoleplayer].playerstate = PST_LIVE;  // not reborn
        advancedemo = false;
        game.usergame = false;               // no save / end game here
        game.paused = false;
        game.gameaction = ga_nothing;

        if ( game.gameMode == GameMode.RETAIL ) {
            demosequence = (demosequence+1)%7;
        } else {
            demosequence = (demosequence+1)%6;
        }

        switch (demosequence) {
          case 0:
            if ( game.gameMode == GameMode.COMMERCIAL ) {
                pagetic = 35 * 11;
            } else {
                pagetic = 170;
            }
            game.gamestate = GS_DEMOSCREEN;
            pagename = "TITLEPIC";
            if ( game.gameMode == GameMode.COMMERCIAL ) {
                game.sound.S_StartMusic(mus_dm2ttl);
            } else {
                game.sound.S_StartMusic (mus_intro);
            }
            break;
          case 1:
            game.G_DeferedPlayDemo ("demo1");
            break;
          case 2:
            pagetic = 200;
            game.gamestate = GS_DEMOSCREEN;
            pagename = "CREDIT";
            break;
          case 3:
            game.G_DeferedPlayDemo ("demo2");
            break;
          case 4:
            game.gamestate = GS_DEMOSCREEN;
            if ( game.gameMode == GameMode.COMMERCIAL)
            {
                pagetic = 35 * 11;
                pagename = "TITLEPIC";
                game.sound.S_StartMusic(mus_dm2ttl);
            }
            else
            {
                pagetic = 200;

                if ( game.gameMode == GameMode.RETAIL ) {
                    pagename = "CREDIT";
                } else {
                    pagename = "HELP2";
                }
            }
            break;
          case 5:
            game.G_DeferedPlayDemo ("demo3");
            break;
            // THE DEFINITIVE DOOM Special Edition demo
          case 6:
            game.G_DeferedPlayDemo ("demo4");
            break;
        }
    }
     
    //
    // D_StartTitle
    //
    public void D_StartTitle () {
        game.gameaction = GameAction.ga_nothing;
        demosequence = -1;
        D_AdvanceDemo ();
    }


    //
    // IdentifyVersion
    // Checks availability of IWAD files by name,
    // to determine whether registered/commercial features
    // should be executed (notably loading PWAD's).
    //
    private void identifyVersion () {

        String	doom1wad;
        String	doomwad;
        String	doomuwad;
        String	doom2wad;

        String	doom2fwad;
        String	plutoniawad;
        String	tntwad;

        //String home = System.getProperty("user.home");
        //String doomwaddir = getenv("DOOMWADDIR");
        File wadDir = new File(doomWadDir);
        if (!wadDir.isDirectory() ) {
        //if ( !File.)
            doomWadDir = ".";
        }
        
        // Commercial.
        doom2wad = doomWadDir + File.separator + "doom2.wad";

        // Retail.
        doomuwad = doomWadDir + File.separator + "doomu.wad";

        // Registered.
        doomwad = doomWadDir + File.separator + "doom.wad";

        // Shareware.
        doom1wad = doomWadDir + File.separator + "doom1.wad";

        // Plutonia
        plutoniawad = doomWadDir + File.separator + "plutonia.wad";
        

        // TNT
        tntwad = doomWadDir + File.separator + "tnt.wad";


        // French stuff.
        doom2fwad = doomWadDir + File.separator + "doom2f.wad";

        //home = getenv("HOME");
//        if (!home)
//          I_Error("Please set $HOME to your home directory");
        if ( !new File(homeDir).isDirectory() ) {
            logger.severe("Home directory not found.\n");
        }
        
        //slogger.log(Level.CONFIG, basedefault, "%s/.doomrc", home);
        basedefault = homeDir + File.separator + ".doomrc";

        if (game.isParam("-shdev")) {
            game.gameMode = GameMode.SHAREWARE;
            devparm = true;
            //D_AddFile (DEVDATA"doom1.wad");
            wadList.add(DEVDATA + "doom1.wad");
            //D_AddFile (DEVMAPS"data_se/texture1.lmp");
            wadList.add(DEVMAPS + "data_se/texture1.lmp");
            //D_AddFile (DEVMAPS"data_se/pnames.lmp");
            wadList.add(DEVMAPS + "data_se/pnames.lmp");
            //strcpy (basedefault,DEVDATA"default.cfg");
            basedefault = DEVDATA + "default.cfg";
            return;
        }

        if (game.isParam("-regdev")) {
            game.gameMode = GameMode.REGISTERED;
            devparm = true;
            //D_AddFile (DEVDATA"doom.wad");
            wadList.add(DEVDATA + "doom1.wad");
            //D_AddFile (DEVMAPS"data_se/texture1.lmp");
            wadList.add(DEVMAPS + "data_se/texture1.lmp");
            //D_AddFile (DEVMAPS"data_se/texture2.lmp");
            wadList.add(DEVMAPS + "data_se/texture2.lmp");
            //D_AddFile (DEVMAPS"data_se/pnames.lmp");
            wadList.add(DEVMAPS + "data_se/pnames.lmp");
            //strcpy (basedefault,DEVDATA"default.cfg");
            basedefault = DEVDATA + "default.cfg";
            return;
        }

        if (game.isParam("-comdev")) {
            game.gameMode = GameMode.COMMERCIAL;
            devparm = true;

     // I don't bother
//            if(plutonia)
//                D_AddFile (DEVDATA"plutonia.wad");
//            else if(tnt)
//                D_AddFile (DEVDATA"tnt.wad");
//            else

            //D_AddFile (DEVDATA"doom2.wad");  
            wadList.add(DEVDATA + "doom2.wad");
            //D_AddFile (DEVMAPS"cdata/texture1.lmp");
            wadList.add(DEVMAPS + "data_se/texture1.lmp");
            //D_AddFile (DEVMAPS"cdata/pnames.lmp");
            wadList.add(DEVMAPS + "data_se/pnames.lmp");
            //strcpy (basedefault,DEVDATA"default.cfg");
            basedefault = DEVDATA + "default.cfg";
            return;
       }
    
        if ( new File(doom2fwad).canRead() ) {
        //if ( !access (doom2fwad,R_OK) ) {
            game.gameMode = GameMode.COMMERCIAL;
            // C'est ridicule!
            // Let's handle languages in config files, okay?
            Game.country =  "FR";
            Game.language = "fr";
            logger.log(Level.CONFIG, "Version: French Doom2\n");
            //D_AddFile (doom2fwad);
            wadList.add(doom2fwad);
            return;
        }

        if ( new File(doom2wad).canRead() ) {
        //if ( !access (doom2wad,R_OK) ) {
            game.gameMode = GameMode.COMMERCIAL;
            //D_AddFile (doom2wad);
            wadList.add(doom2wad);
            logger.log(Level.CONFIG, "Version: Doom2\n");
            return;
        }

        if ( new File(plutoniawad).canRead() ) {
        //if ( !access (plutoniawad, R_OK ) ) {
            game.gameMode = GameMode.COMMERCIAL;
            //D_AddFile (plutoniawad);
            wadList.add(plutoniawad);
            logger.log(Level.CONFIG, "Version: Plutonia\n");
            return;
        }

        if ( new File(tntwad).canRead() ) {
        //if ( !access ( tntwad, R_OK ) ) {
            game.gameMode = GameMode.COMMERCIAL;
            //D_AddFile (tntwad);
            wadList.add(tntwad);
            logger.log(Level.CONFIG, "Version: TnT\n");
            return;
        }

        if ( new File(doomuwad).canRead() ) {
        //if ( !access (doomuwad,R_OK) ) {
            game.gameMode = GameMode.RETAIL;
            //D_AddFile (doomuwad);
            wadList.add(doomuwad);
            logger.log(Level.CONFIG, "Version: Retail\n");
            return;
        }

        if ( new File(doomwad).canRead() ) {
        //if ( !access (doomwad,R_OK) ) {
            game.gameMode = GameMode.REGISTERED;
            //D_AddFile (doomwad);
            wadList.add(doomwad);
            logger.log(Level.CONFIG, "Version: Registered\n");
            return;
        }

        if ( new File(doom1wad).canRead() ) {
        //if ( !access (doom1wad,R_OK) ) {
            game.gameMode = GameMode.SHAREWARE;
            //D_AddFile (doom1wad);
            wadList.add(doom1wad);
            logger.log(Level.CONFIG, "Version: Shareware\n");
            return;
        }

        logger.log(Level.CONFIG, "Game mode indeterminate.\n");
        game.gameMode = GameMode.INDETERMINED;

        // We don't abort. Let's see what the PWAD contains.
        //exit(1);
        SystemInterface.I_Error ("Game mode indeterminate");
    }

}
